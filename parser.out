Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    PRINT
    assign
    comment
    var

Grammar

Rule 0     S' -> program
Rule 1     program -> start commands end
Rule 2     commands -> commands command ;
Rule 3     commands -> command ;
Rule 4     command -> ESCREVER args
Rule 5     args -> args , arg
Rule 6     args -> arg
Rule 7     arg -> string
Rule 8     arg -> expr
Rule 9     expr -> expr + expr
Rule 10    expr -> expr - expr
Rule 11    expr -> expr * expr
Rule 12    expr -> expr / expr
Rule 13    expr -> num
Rule 14    expr -> ( num )

Terminals, with rules where they appear

(                    : 14
)                    : 14
*                    : 11
+                    : 9
,                    : 5
-                    : 10
/                    : 12
;                    : 2 3
ESCREVER             : 4
PRINT                : 
assign               : 
comment              : 
end                  : 1
error                : 
num                  : 13 14
start                : 1
string               : 7
var                  : 

Nonterminals, with rules where they appear

arg                  : 5 6
args                 : 4 5
command              : 2 3
commands             : 1 2
expr                 : 8 9 9 10 10 11 11 12 12
program              : 0

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . start commands end

    start           shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> start . commands end
    (2) commands -> . commands command ;
    (3) commands -> . command ;
    (4) command -> . ESCREVER args

    ESCREVER        shift and go to state 5

    commands                       shift and go to state 3
    command                        shift and go to state 4

state 3

    (1) program -> start commands . end
    (2) commands -> commands . command ;
    (4) command -> . ESCREVER args

    end             shift and go to state 6
    ESCREVER        shift and go to state 5

    command                        shift and go to state 7

state 4

    (3) commands -> command . ;

    ;               shift and go to state 8


state 5

    (4) command -> ESCREVER . args
    (5) args -> . args , arg
    (6) args -> . arg
    (7) arg -> . string
    (8) arg -> . expr
    (9) expr -> . expr + expr
    (10) expr -> . expr - expr
    (11) expr -> . expr * expr
    (12) expr -> . expr / expr
    (13) expr -> . num
    (14) expr -> . ( num )

    string          shift and go to state 11
    num             shift and go to state 13
    (               shift and go to state 14

    args                           shift and go to state 9
    arg                            shift and go to state 10
    expr                           shift and go to state 12

state 6

    (1) program -> start commands end .

    $end            reduce using rule 1 (program -> start commands end .)


state 7

    (2) commands -> commands command . ;

    ;               shift and go to state 15


state 8

    (3) commands -> command ; .

    end             reduce using rule 3 (commands -> command ; .)
    ESCREVER        reduce using rule 3 (commands -> command ; .)


state 9

    (4) command -> ESCREVER args .
    (5) args -> args . , arg

    ;               reduce using rule 4 (command -> ESCREVER args .)
    ,               shift and go to state 16


state 10

    (6) args -> arg .

    ,               reduce using rule 6 (args -> arg .)
    ;               reduce using rule 6 (args -> arg .)


state 11

    (7) arg -> string .

    ,               reduce using rule 7 (arg -> string .)
    ;               reduce using rule 7 (arg -> string .)


state 12

    (8) arg -> expr .
    (9) expr -> expr . + expr
    (10) expr -> expr . - expr
    (11) expr -> expr . * expr
    (12) expr -> expr . / expr

    ,               reduce using rule 8 (arg -> expr .)
    ;               reduce using rule 8 (arg -> expr .)
    +               shift and go to state 17
    -               shift and go to state 18
    *               shift and go to state 19
    /               shift and go to state 20


state 13

    (13) expr -> num .

    +               reduce using rule 13 (expr -> num .)
    -               reduce using rule 13 (expr -> num .)
    *               reduce using rule 13 (expr -> num .)
    /               reduce using rule 13 (expr -> num .)
    ,               reduce using rule 13 (expr -> num .)
    ;               reduce using rule 13 (expr -> num .)


state 14

    (14) expr -> ( . num )

    num             shift and go to state 21


state 15

    (2) commands -> commands command ; .

    end             reduce using rule 2 (commands -> commands command ; .)
    ESCREVER        reduce using rule 2 (commands -> commands command ; .)


state 16

    (5) args -> args , . arg
    (7) arg -> . string
    (8) arg -> . expr
    (9) expr -> . expr + expr
    (10) expr -> . expr - expr
    (11) expr -> . expr * expr
    (12) expr -> . expr / expr
    (13) expr -> . num
    (14) expr -> . ( num )

    string          shift and go to state 11
    num             shift and go to state 13
    (               shift and go to state 14

    arg                            shift and go to state 22
    expr                           shift and go to state 12

state 17

    (9) expr -> expr + . expr
    (9) expr -> . expr + expr
    (10) expr -> . expr - expr
    (11) expr -> . expr * expr
    (12) expr -> . expr / expr
    (13) expr -> . num
    (14) expr -> . ( num )

    num             shift and go to state 13
    (               shift and go to state 14

    expr                           shift and go to state 23

state 18

    (10) expr -> expr - . expr
    (9) expr -> . expr + expr
    (10) expr -> . expr - expr
    (11) expr -> . expr * expr
    (12) expr -> . expr / expr
    (13) expr -> . num
    (14) expr -> . ( num )

    num             shift and go to state 13
    (               shift and go to state 14

    expr                           shift and go to state 24

state 19

    (11) expr -> expr * . expr
    (9) expr -> . expr + expr
    (10) expr -> . expr - expr
    (11) expr -> . expr * expr
    (12) expr -> . expr / expr
    (13) expr -> . num
    (14) expr -> . ( num )

    num             shift and go to state 13
    (               shift and go to state 14

    expr                           shift and go to state 25

state 20

    (12) expr -> expr / . expr
    (9) expr -> . expr + expr
    (10) expr -> . expr - expr
    (11) expr -> . expr * expr
    (12) expr -> . expr / expr
    (13) expr -> . num
    (14) expr -> . ( num )

    num             shift and go to state 13
    (               shift and go to state 14

    expr                           shift and go to state 26

state 21

    (14) expr -> ( num . )

    )               shift and go to state 27


state 22

    (5) args -> args , arg .

    ,               reduce using rule 5 (args -> args , arg .)
    ;               reduce using rule 5 (args -> args , arg .)


state 23

    (9) expr -> expr + expr .
    (9) expr -> expr . + expr
    (10) expr -> expr . - expr
    (11) expr -> expr . * expr
    (12) expr -> expr . / expr

    +               reduce using rule 9 (expr -> expr + expr .)
    -               reduce using rule 9 (expr -> expr + expr .)
    ,               reduce using rule 9 (expr -> expr + expr .)
    ;               reduce using rule 9 (expr -> expr + expr .)
    *               shift and go to state 19
    /               shift and go to state 20

  ! *               [ reduce using rule 9 (expr -> expr + expr .) ]
  ! /               [ reduce using rule 9 (expr -> expr + expr .) ]
  ! +               [ shift and go to state 17 ]
  ! -               [ shift and go to state 18 ]


state 24

    (10) expr -> expr - expr .
    (9) expr -> expr . + expr
    (10) expr -> expr . - expr
    (11) expr -> expr . * expr
    (12) expr -> expr . / expr

    +               reduce using rule 10 (expr -> expr - expr .)
    -               reduce using rule 10 (expr -> expr - expr .)
    ,               reduce using rule 10 (expr -> expr - expr .)
    ;               reduce using rule 10 (expr -> expr - expr .)
    *               shift and go to state 19
    /               shift and go to state 20

  ! *               [ reduce using rule 10 (expr -> expr - expr .) ]
  ! /               [ reduce using rule 10 (expr -> expr - expr .) ]
  ! +               [ shift and go to state 17 ]
  ! -               [ shift and go to state 18 ]


state 25

    (11) expr -> expr * expr .
    (9) expr -> expr . + expr
    (10) expr -> expr . - expr
    (11) expr -> expr . * expr
    (12) expr -> expr . / expr

    +               reduce using rule 11 (expr -> expr * expr .)
    -               reduce using rule 11 (expr -> expr * expr .)
    *               reduce using rule 11 (expr -> expr * expr .)
    /               reduce using rule 11 (expr -> expr * expr .)
    ,               reduce using rule 11 (expr -> expr * expr .)
    ;               reduce using rule 11 (expr -> expr * expr .)

  ! +               [ shift and go to state 17 ]
  ! -               [ shift and go to state 18 ]
  ! *               [ shift and go to state 19 ]
  ! /               [ shift and go to state 20 ]


state 26

    (12) expr -> expr / expr .
    (9) expr -> expr . + expr
    (10) expr -> expr . - expr
    (11) expr -> expr . * expr
    (12) expr -> expr . / expr

    +               reduce using rule 12 (expr -> expr / expr .)
    -               reduce using rule 12 (expr -> expr / expr .)
    *               reduce using rule 12 (expr -> expr / expr .)
    /               reduce using rule 12 (expr -> expr / expr .)
    ,               reduce using rule 12 (expr -> expr / expr .)
    ;               reduce using rule 12 (expr -> expr / expr .)

  ! +               [ shift and go to state 17 ]
  ! -               [ shift and go to state 18 ]
  ! *               [ shift and go to state 19 ]
  ! /               [ shift and go to state 20 ]


state 27

    (14) expr -> ( num ) .

    +               reduce using rule 14 (expr -> ( num ) .)
    -               reduce using rule 14 (expr -> ( num ) .)
    *               reduce using rule 14 (expr -> ( num ) .)
    /               reduce using rule 14 (expr -> ( num ) .)
    ,               reduce using rule 14 (expr -> ( num ) .)
    ;               reduce using rule 14 (expr -> ( num ) .)

